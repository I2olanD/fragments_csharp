// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

public struct Meshes : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static Meshes GetRootAsMeshes(ByteBuffer _bb) { return GetRootAsMeshes(_bb, new Meshes()); }
  public static Meshes GetRootAsMeshes(ByteBuffer _bb, Meshes obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Meshes __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Transform? Coordinates { get { int o = __p.__offset(4); return o != 0 ? (Transform?)(new Transform()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public uint MeshesItems(int j) { int o = __p.__offset(6); return o != 0 ? __p.bb.GetUint(__p.__vector(o) + j * 4) : (uint)0; }
  public int MeshesItemsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<uint> GetMeshesItemsBytes() { return __p.__vector_as_span<uint>(6, 4); }
#else
  public ArraySegment<byte>? GetMeshesItemsBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public uint[] GetMeshesItemsArray() { return __p.__vector_as_array<uint>(6); }
  public Sample? Samples(int j) { int o = __p.__offset(8); return o != 0 ? (Sample?)(new Sample()).__assign(__p.__vector(o) + j * 16, __p.bb) : null; }
  public int SamplesLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Representation? Representations(int j) { int o = __p.__offset(10); return o != 0 ? (Representation?)(new Representation()).__assign(__p.__vector(o) + j * 32, __p.bb) : null; }
  public int RepresentationsLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Material? Materials(int j) { int o = __p.__offset(12); return o != 0 ? (Material?)(new Material()).__assign(__p.__vector(o) + j * 6, __p.bb) : null; }
  public int MaterialsLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
  public CircleExtrusion? CircleExtrusions(int j) { int o = __p.__offset(14); return o != 0 ? (CircleExtrusion?)(new CircleExtrusion()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int CircleExtrusionsLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Shell? Shells(int j) { int o = __p.__offset(16); return o != 0 ? (Shell?)(new Shell()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int ShellsLength { get { int o = __p.__offset(16); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Transform? LocalTransforms(int j) { int o = __p.__offset(18); return o != 0 ? (Transform?)(new Transform()).__assign(__p.__vector(o) + j * 48, __p.bb) : null; }
  public int LocalTransformsLength { get { int o = __p.__offset(18); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Transform? GlobalTransforms(int j) { int o = __p.__offset(20); return o != 0 ? (Transform?)(new Transform()).__assign(__p.__vector(o) + j * 48, __p.bb) : null; }
  public int GlobalTransformsLength { get { int o = __p.__offset(20); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static void StartMeshes(FlatBufferBuilder builder) { builder.StartTable(9); }
  public static void AddCoordinates(FlatBufferBuilder builder, Offset<Transform> coordinatesOffset) { builder.AddStruct(0, coordinatesOffset.Value, 0); }
  public static void AddMeshesItems(FlatBufferBuilder builder, VectorOffset meshesItemsOffset) { builder.AddOffset(1, meshesItemsOffset.Value, 0); }
  public static VectorOffset CreateMeshesItemsVector(FlatBufferBuilder builder, uint[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddUint(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateMeshesItemsVectorBlock(FlatBufferBuilder builder, uint[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMeshesItemsVectorBlock(FlatBufferBuilder builder, ArraySegment<uint> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMeshesItemsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<uint>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartMeshesItemsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSamples(FlatBufferBuilder builder, VectorOffset samplesOffset) { builder.AddOffset(2, samplesOffset.Value, 0); }
  public static void StartSamplesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(16, numElems, 4); }
  public static void AddRepresentations(FlatBufferBuilder builder, VectorOffset representationsOffset) { builder.AddOffset(3, representationsOffset.Value, 0); }
  public static void StartRepresentationsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(32, numElems, 4); }
  public static void AddMaterials(FlatBufferBuilder builder, VectorOffset materialsOffset) { builder.AddOffset(4, materialsOffset.Value, 0); }
  public static void StartMaterialsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(6, numElems, 1); }
  public static void AddCircleExtrusions(FlatBufferBuilder builder, VectorOffset circleExtrusionsOffset) { builder.AddOffset(5, circleExtrusionsOffset.Value, 0); }
  public static VectorOffset CreateCircleExtrusionsVector(FlatBufferBuilder builder, Offset<CircleExtrusion>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateCircleExtrusionsVectorBlock(FlatBufferBuilder builder, Offset<CircleExtrusion>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCircleExtrusionsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<CircleExtrusion>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCircleExtrusionsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<CircleExtrusion>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCircleExtrusionsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddShells(FlatBufferBuilder builder, VectorOffset shellsOffset) { builder.AddOffset(6, shellsOffset.Value, 0); }
  public static VectorOffset CreateShellsVector(FlatBufferBuilder builder, Offset<Shell>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateShellsVectorBlock(FlatBufferBuilder builder, Offset<Shell>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateShellsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Shell>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateShellsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Shell>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartShellsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddLocalTransforms(FlatBufferBuilder builder, VectorOffset localTransformsOffset) { builder.AddOffset(7, localTransformsOffset.Value, 0); }
  public static void StartLocalTransformsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(48, numElems, 8); }
  public static void AddGlobalTransforms(FlatBufferBuilder builder, VectorOffset globalTransformsOffset) { builder.AddOffset(8, globalTransformsOffset.Value, 0); }
  public static void StartGlobalTransformsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(48, numElems, 8); }
  public static Offset<Meshes> EndMeshes(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // coordinates
    builder.Required(o, 6);  // meshes_items
    builder.Required(o, 8);  // samples
    builder.Required(o, 10);  // representations
    builder.Required(o, 12);  // materials
    builder.Required(o, 14);  // circle_extrusions
    builder.Required(o, 16);  // shells
    builder.Required(o, 18);  // local_transforms
    builder.Required(o, 20);  // global_transforms
    return new Offset<Meshes>(o);
  }
}


static public class MeshesVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Coordinates*/, 48 /*Transform*/, 8, true)
      && verifier.VerifyVectorOfData(tablePos, 6 /*MeshesItems*/, 4 /*uint*/, true)
      && verifier.VerifyVectorOfData(tablePos, 8 /*Samples*/, 16 /*Sample*/, true)
      && verifier.VerifyVectorOfData(tablePos, 10 /*Representations*/, 32 /*Representation*/, true)
      && verifier.VerifyVectorOfData(tablePos, 12 /*Materials*/, 6 /*Material*/, true)
      && verifier.VerifyVectorOfTables(tablePos, 14 /*CircleExtrusions*/, CircleExtrusionVerify.Verify, true)
      && verifier.VerifyVectorOfTables(tablePos, 16 /*Shells*/, ShellVerify.Verify, true)
      && verifier.VerifyVectorOfData(tablePos, 18 /*LocalTransforms*/, 48 /*Transform*/, true)
      && verifier.VerifyVectorOfData(tablePos, 20 /*GlobalTransforms*/, 48 /*Transform*/, true)
      && verifier.VerifyTableEnd(tablePos);
  }
}
